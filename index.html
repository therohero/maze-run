<!DOCTYPE html>
<html>
    <head>
        <title>Maze Escape</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            html, body {
                margin: 0;
                padding: 0;
                width: 100vw;
                height: 100vh;
                overflow: hidden;
                background: #111;
            }
            #gameCanvas {
                display: block;
                position: absolute;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: #111;
            }
            #gameEndOverlay {
                display: none;
                position: fixed;
                left: 0; top: 0; width: 100vw; height: 100vh;
                background: rgba(0,0,0,0.8);
                z-index: 100;
                align-items: center;
                justify-content: center;
            }
            #gameEndContent {
                background:#222;
                color:#fff;
                padding:40px 60px;
                border-radius:20px;
                text-align:center;
                min-width:400px;
                box-shadow:0 0 40px #000;
            }
        </style>
    </head>
    <body>
        <div id="startScreen" style="position:fixed;left:0;top:0;width:100vw;height:100vh;background:#111;z-index:200;display:flex;align-items:center;justify-content:center;">
            <div style="background:#222;padding:40px 60px;border-radius:20px;box-shadow:0 0 40px #000;text-align:center;min-width:400px;">
                <h1 style="color:#FFD700;">Maze Escape</h1>
                <p style="color:#fff;font-size:1.2em;">Finde den Ausgang, ohne vom Geist erwischt zu werden!<br>Jeder 11. Spieler wird automatisch ein Geist.<br>Gib deinen Namen ein, um zu starten:</p>
                <input id="nameInput" type="text" maxlength="16" placeholder="Dein Name" style="font-size:1.2em;padding:8px 16px;border-radius:8px;border:none;outline:none;">
                <br><br>
                <button id="startBtn" style="font-size:1.2em;padding:8px 32px;border-radius:8px;background:#FFD700;color:#222;border:none;cursor:pointer;">Start</button>
            </div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <button id="lockBtn" style="position:absolute;top:10px;right:10px;z-index:10;">Keiner kommt mehr!</button>
        <div id="gameEndOverlay">
            <div id="gameEndContent"></div>
        </div>

        <script>
            let players = [];
            let id;
            let keyState = {};

            const $ = id => document.getElementById(id);
            const canvas = $('gameCanvas');
            const ctx = canvas.getContext('2d');

            const GAME_WIDTH = 1920;
            const GAME_HEIGHT = 1080;

            let lastWidth = 0;
            let lastHeight = 0;
            let lastLag = 0;

            let ghostImg = new Image();
            ghostImg.src = "ghost.png";
            let mauerImg = new Image();
            mauerImg.src = "mauer.png";
            let playerImg = new Image();
            playerImg.src = "player.png";

            function fitCanvas() {
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                const scale = Math.min(windowWidth / GAME_WIDTH, windowHeight / GAME_HEIGHT);

                canvas.width = GAME_WIDTH;
                canvas.height = GAME_HEIGHT;

                canvas.style.width = `${GAME_WIDTH * scale}px`;
                canvas.style.height = `${GAME_HEIGHT * scale}px`;
                canvas.style.left = '50%';
                canvas.style.top = '50%';
                canvas.style.transform = 'translate(-50%, -50%)';

                lastWidth = windowWidth;
                lastHeight = windowHeight;
            }

            window.addEventListener('resize', fitCanvas);
            window.addEventListener('fullscreenchange', fitCanvas);
            window.addEventListener('webkitfullscreenchange', fitCanvas);
            window.addEventListener('zfullscreenchange', fitCanvas);

            fitCanvas();

            let maze = [];
            let cols = 0;
            let rows = 0;
            const CELL_SIZE = 40;

            async function loadMaze() {
                const res = await fetch('/maze');
                const data = await res.json();
                maze = data.maze;
                cols = data.cols;
                rows = data.rows;
            }

            let showGameStart = false;
            let showRole = '';
            let gameStartDisplayTime = 0;
            let lastGameLocked = false;

            function updateGameStartDisplay() {
                // Wenn das Spiel gerade gelockt wurde (Übergang von false zu true)
                if (!lastGameLocked && gameLocked) {
                    showGameStart = true;
                    gameStartDisplayTime = Date.now();
                    // Rolle bestimmen
                    const myPlayer = players.find(p => p.id === id);
                    if (myPlayer && myPlayer.isGhost) showRole = 'GEIST';
                    else showRole = 'SPIELER';
                    setTimeout(() => { showGameStart = false; }, 3000);
                }
                lastGameLocked = gameLocked;
            }

            // Zeige "SPIEL BEGINNT" und Rolle beim Lock
            document.getElementById('lockBtn').onclick = async () => {
                const res = await fetch('/lock', { method: 'POST' });
                if (res.ok) {
                    document.getElementById('lockBtn').style.display = 'none';
                    showGameStart = true;
                    gameStartDisplayTime = Date.now();
                    // Rolle bestimmen
                    const myPlayer = players.find(p => p.id === id);
                    if (myPlayer && myPlayer.isGhost) showRole = 'GEIST';
                    else showRole = 'SPIELER';

                    // Geisternamen für Anzeige im GameStart speichern
                    const data = await res.json();
                    const ghostIds = data.ghosts;
                    if (!players || players.length === 0) players = await fetchPlayers();
                    window._lastGhostNames = players.filter(p => ghostIds.includes(p.id)).map(p => p.name && p.name.trim() ? p.name : 'Spieler');

                    setTimeout(() => { showGameStart = false; window._lastGhostNames = []; }, 3000);
                } else {
                    alert('Spiel kann nicht gesperrt werden!');
                }
            };

            function drawMaze() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // Wände zeichnen (grau)
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        if (maze[y] && maze[y][x] === 0) { // 0 = Wand
                            ctx.drawImage(mauerImg, x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        }
                    }
                }
                // Spieler & Geister zeichnen
                for (const player of players) {
                    if (player.death) continue;
                    let px = player.x * CELL_SIZE;
                    let py = player.y * CELL_SIZE;
                    if (player.isGhost) {
                        ctx.drawImage(ghostImg, px, py, CELL_SIZE, CELL_SIZE);
                    } else {
                        ctx.drawImage(playerImg, px, py, CELL_SIZE, CELL_SIZE);
                    }
                    // Name über Kopf anzeigen (immer, Fallback: 'Spieler')
                    const pname = player.name && player.name.trim() ? player.name : 'Spieler';
                    ctx.font = 'bold 18px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = '#fff';
                    ctx.strokeStyle = '#111';
                    ctx.lineWidth = 4;
                    ctx.strokeText(pname, px + CELL_SIZE/2, py - 6);
                    ctx.fillText(pname, px + CELL_SIZE/2, py - 6);
                }
            }

            async function fetchPlayers() {
                const res = await fetch('/players');
                const data = await res.json();
                players = data.players;
                gameLocked = data.gameLocked;
                return players;
            }

            async function tryMove(dir) {
                const start = performance.now();
                const res = await fetch(`/move?dir=${dir}&id=${id}`);
                const end = performance.now();
                lastLag = Math.round(end - start); // Latenz in ms

                if (!res.ok) {
                    try {
                        const err = await res.json();
                        console.log('Fehler:', err.error);
                    } catch {
                        console.log('Serverfehler');
                    }
                    return;
                }
                await res.json();
            }

            function drawLag() {
                ctx.font = '20px monospace';
                ctx.fillStyle = 'yellow';
                ctx.fillText(`Lag: ${lastLag} ms`, 10, 30);
            }

            let gameResult = null;
            let timer = 0;

            async function fetchStatus() {
                const res = await fetch('/status');
                const data = await res.json();
                timer = data.timeLeft;
                gameLocked = data.gameLocked;
            }

            function drawTimerAndResult() {
                ctx.font = '24px monospace';
                ctx.fillStyle = 'yellow';
                if (!gameResult) {
                    // Timer anzeigen (Restzeit in Minuten:Sekunden)
                    const min = Math.floor(timer / 60);
                    const sec = timer % 60;
                    ctx.fillText(`Zeit: ${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`, 10, 60);
                }
            }

            function showGameEnd(result) {
                const overlay = document.getElementById('gameEndOverlay');
                const content = document.getElementById('gameEndContent');
                let html = `<h1 style="color:#FFD700; font-size:3em; margin-bottom:0.2em;">SPIEL ENDET</h1>`;
                html += `<h2 style="color:#00FFFF; margin-bottom:1em;">Gewinner: ${result.result.winner}</h2>`;
                html += `<table style="margin:auto; font-size:1.3em; border-collapse:collapse;">
                    <tr>
                        <th style="padding:8px 16px;">Player</th>
                        <th style="padding:8px 16px;">Rolle</th>
                        <th style="padding:8px 16px;">Kills</th>
                        <th style="padding:8px 16px;">Überlebenszeit</th>
                    </tr>`;
                players.forEach((p, i) => {
                    let rolle = p.isGhost ? 'Geist' : 'Spieler';
                    let kills = 0;
                    let zeit = '';
                    if (p.isGhost) {
                        kills = result.result.ghosts.find(g => g.id === p.id)?.kills ?? 0;
                        zeit = '-';
                    } else {
                        const survivor = result.result.survivors.find(s => s.id === p.id);
                        const liveTime = survivor ? survivor.liveTime : 0;
                        kills = Math.floor((liveTime/1000) / 120); // 2 Minuten = 120 Sekunden = 1 Kill
                        zeit = Math.round((liveTime/1000)) + ' s';
                    }
                    html += `<tr>
                        <td style="padding:8px 16px;">Player ${i+1}</td>
                        <td style="padding:8px 16px;">${rolle}</td>
                        <td style="padding:8px 16px;">${kills}</td>
                        <td style="padding:8px 16px;">${zeit}</td>
                    </tr>`;
                });
                html += `</table>`;
                content.innerHTML = html;
                overlay.style.display = 'flex';
                setTimeout(() => {
                    overlay.style.display = 'none';
                }, 10000); // 10 Sekunden anzeigen
            }

            async function pollResult() {
                const res = await fetch('/result');
                const data = await res.json();
                if (!data.running) {
                    gameResult = data;
                    showGameEnd(data); // Overlay anzeigen
                    setTimeout(async () => {
                        gameResult = null;
                        document.getElementById('lockBtn').style.display = 'block';
                        timer = 10 * 60;
                        await loadMaze(); // Maze neu laden!
                    }, 10000);
                }
            }

            function updateTimer() {
                if (!gameResult) {
                    if (gameLocked && timer > 0) timer--;
                }
            }

            // Anzeige im Game Loop
            function drawGameStart() {
                if (showGameStart) {
                    ctx.save();
                    ctx.font = 'bold 80px Arial';
                    ctx.fillStyle = '#FFD700';
                    ctx.textAlign = 'center';
                    ctx.fillText('SPIEL BEGINNT', canvas.width / 2, canvas.height / 2 - 40);
                    ctx.font = 'bold 50px Arial';
                    ctx.fillStyle = '#00FFFF';
                    ctx.fillText(showRole, canvas.width / 2, canvas.height / 2 + 40);

                    // Geisterliste unter der Rolle anzeigen
                    if (window._lastGhostNames && window._lastGhostNames.length > 0) {
                        ctx.font = 'bold 28px Arial';
                        ctx.fillStyle = '#fff';
                        ctx.textAlign = 'center';
                        ctx.fillText('Geister:', canvas.width / 2, canvas.height / 2 + 90);
                        ctx.font = '24px Arial';
                        let y = canvas.height / 2 + 120;
                        for (const n of window._lastGhostNames) {
                            ctx.fillText('👻 ' + n, canvas.width / 2, y);
                            y += 32;
                        }
                    }
                    ctx.restore();
                }
            }

            // Joystick-Overlay für Touch-Steuerung
            let joystickActive = false;
            let joystickCenter = { x: 0, y: 0 };
            let joystickPointer = { x: 0, y: 0 };
            let joystickDir = null;
            let joystickMoveInterval = null;

            function drawJoystick() {
                if (!joystickActive) return;
                const ctx2 = ctx;
                ctx2.save();
                ctx2.globalAlpha = 0.4;
                ctx2.beginPath();
                ctx2.arc(joystickCenter.x, joystickCenter.y, 80, 0, 2 * Math.PI);
                ctx2.fillStyle = "#888";
                ctx2.fill();
                ctx2.globalAlpha = 1.0;
                ctx2.beginPath();
                ctx2.arc(joystickPointer.x, joystickPointer.y, 32, 0, 2 * Math.PI);
                ctx2.fillStyle = "#FFD700";
                ctx2.fill();
                ctx2.restore();
            }

            // Joystick-Richtung bestimmen
            function getJoystickDir(dx, dy) {
                if (Math.abs(dx) < 20 && Math.abs(dy) < 20) return null;
                if (Math.abs(dx) > Math.abs(dy)) {
                    return dx > 0 ? 'right' : 'left';
                } else {
                    return dy > 0 ? 'down' : 'up';
                }
            }

            function startJoystickMove(dir) {
                if (joystickMoveInterval) clearInterval(joystickMoveInterval);
                joystickDir = dir;
                if (dir) mobileMove(dir);
                joystickMoveInterval = setInterval(() => {
                    if (joystickDir) mobileMove(joystickDir);
                }, 120);
            }

            function stopJoystickMove() {
                if (joystickMoveInterval) clearInterval(joystickMoveInterval);
                joystickMoveInterval = null;
                joystickDir = null;
                joystickActive = false;
            }

            // Touch-Events für Joystick
            canvas.addEventListener('touchstart', function(e) {
                if (e.touches.length === 1) {
                    const rect = canvas.getBoundingClientRect();
                    const x = (e.touches[0].clientX - rect.left) * (canvas.width / rect.width);
                    const y = (e.touches[0].clientY - rect.top) * (canvas.height / rect.height);
                    joystickActive = true;
                    joystickCenter = { x, y };
                    joystickPointer = { x, y };
                    joystickDir = null;
                    drawMaze();
                    drawJoystick();
                }
            });

            canvas.addEventListener('touchmove', function(e) {
                if (!joystickActive) return;
                const rect = canvas.getBoundingClientRect();
                const x = (e.touches[0].clientX - rect.left) * (canvas.width / rect.width);
                const y = (e.touches[0].clientY - rect.top) * (canvas.height / rect.height);
                // Begrenze den Pointer auf einen Radius von 80px um das Zentrum
                const dx = x - joystickCenter.x;
                const dy = y - joystickCenter.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                let px = x, py = y;
                if (dist > 80) {
                    const angle = Math.atan2(dy, dx);
                    px = joystickCenter.x + Math.cos(angle) * 80;
                    py = joystickCenter.y + Math.sin(angle) * 80;
                }
                joystickPointer = { x: px, y: py };
                // Richtung bestimmen
                const dir = getJoystickDir(px - joystickCenter.x, py - joystickCenter.y);
                if (dir !== joystickDir) {
                    startJoystickMove(dir);
                }
                drawMaze();
                drawJoystick();
            });

            canvas.addEventListener('touchend', function(e) {
                stopJoystickMove();
                drawMaze();
            });

            // Joystick auch im Game-Loop zeichnen
            const origDrawMaze = drawMaze;
            drawMaze = function() {
                origDrawMaze();
                drawJoystick();
            };

            async function gameLoop() {
                await fetchStatus(); // Timer und Lock-Status vom Server holen
                players = await fetchPlayers();
                drawMaze();
                drawTimerAndResult();
                drawGameStart();

                // Button ausblenden, wenn das Spiel gelockt ist
                if (gameLocked) {
                    document.getElementById('lockBtn').style.display = 'none';
                }

                updateGameStartDisplay(); // Hier die Anzeige für alle Spieler steuern

                if (id && !gameResult) {
                    if (keyState['ArrowUp'])    await tryMove('up');
                    if (keyState['ArrowDown'])  await tryMove('down');
                    if (keyState['ArrowLeft'])  await tryMove('left');
                    if (keyState['ArrowRight']) await tryMove('right');
                }
                await pollResult();
                requestAnimationFrame(gameLoop);
            }

            window.addEventListener("keydown", function (e) {
                keyState[e.key] = true;
            });

            window.addEventListener("keyup", function (e) {
                keyState[e.key] = false;
            });

            window.onload = async () => {
                // Starte mit Startscreen
                document.getElementById('startScreen').style.display = 'flex';
                document.getElementById('gameCanvas').style.display = 'none';
                document.getElementById('lockBtn').style.display = 'none';
                document.getElementById('startBtn').onclick = async () => {
                    const name = document.getElementById('nameInput').value.trim().substring(0,16);
                    if (!name) {
                        alert('Bitte gib einen Namen ein!');
                        return;
                    }
                    // Join mit Name
                    const joinRes = await fetch('join?name=' + encodeURIComponent(name));
                    const joinData = await joinRes.json();
                    if (joinData.error) {
                        alert(joinData.error);
                        return;
                    }
                    id = joinData.playerId;
                    localStorage.setItem('playerId', id);
                    localStorage.setItem('playerName', name);
                    document.getElementById('startScreen').style.display = 'none';
                    document.getElementById('gameCanvas').style.display = 'block';
                    document.getElementById('lockBtn').style.display = 'block';
                    await loadMaze();
                    players = await fetchPlayers();
                    drawMaze();
                    gameLoop();
                };
            }

            // Handy-Erkennung
            function isMobile() {
                return /Android|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop/i.test(navigator.userAgent);
            }

            // Touch-Gesten für Wischen/Drücken auf dem ganzen Bildschirm
            let touchStartX = null;
            let touchStartY = null;
            let swipeMoveInterval = null;
            let swipeDir = null;

            function getSwipeDir(dx, dy) {
                if (Math.abs(dx) > Math.abs(dy)) {
                    return dx > 0 ? 'right' : 'left';
                } else {
                    return dy > 0 ? 'down' : 'up';
                }
            }

            function startSwipeMove(dir) {
                if (swipeMoveInterval) clearInterval(swipeMoveInterval);
                swipeDir = dir;
                mobileMove(dir); // Sofort bewegen
                swipeMoveInterval = setInterval(() => {
                    mobileMove(dir);
                }, 120); // alle 120ms bewegen, solange gedrückt
            }

            function stopSwipeMove() {
                if (swipeMoveInterval) clearInterval(swipeMoveInterval);
                swipeMoveInterval = null;
                swipeDir = null;
            }

            canvas.addEventListener('touchstart', function(e) {
                if (e.touches.length === 1) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }
            });

            canvas.addEventListener('touchmove', function(e) {
                if (touchStartX === null || touchStartY === null) return;
                const dx = e.touches[0].clientX - touchStartX;
                const dy = e.touches[0].clientY - touchStartY;
                // Schwelle, damit nicht jede kleine Bewegung zählt
                if (Math.abs(dx) < 30 && Math.abs(dy) < 30) return;
                const dir = getSwipeDir(dx, dy);
                if (swipeDir !== dir) {
                    startSwipeMove(dir);
                }
            });

            canvas.addEventListener('touchend', function(e) {
                stopSwipeMove();
                touchStartX = null;
                touchStartY = null;
            });

            // Funktion für Bewegung (wie gehabt)
            function mobileMove(dir) {
                if (id && !gameResult) {
                    tryMove(dir);
                }
            }
        </script>
    </body>
</html>